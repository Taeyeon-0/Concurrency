# 线程所有权与并发管理

本章将深入探讨C++11中`std::thread`的所有权转移、线程的移动语义、线程容器管理、并行算法实现以及线程标识的使用。通过理论讲解与详细代码示例，帮助读者掌握现代C++并发编程的核心思想与实践方法。

## 1. 线程所有权的转移与移动语义

C++标准库中的`std::thread`、`std::unique_ptr`、`std::ifstream`等资源占有型类型都**可移动（movable）但不可拷贝（copyable）**。这意味着线程的所有权可以在`std::thread`实例之间转移，但不能被复制。

### 1.1 线程所有权转移示例

```cpp
#include <thread>
#include <iostream>

void some_function() {
    std::cout << "some_function running\n";
}
void some_other_function() {
    std::cout << "some_other_function running\n";
}

int main() {
    std::thread t1(some_function);            // 1
    std::thread t2 = std::move(t1);           // 2
    t1 = std::thread(some_other_function);    // 3
    std::thread t3;                           // 4
    t3 = std::move(t2);                       // 5
    // t1 = std::move(t3);                   // 6 (危险！)
    t1.join();
    t3.join();
}
```

- ② `t2 = std::move(t1);` 后，t1不再拥有线程，t2拥有some_function线程。
- ③ `t1 = std::thread(some_other_function);` t1获得新线程。
- ⑤ `t3 = std::move(t2);` t3获得some_function线程。
- ⑥ 若执行`t1 = std::move(t3);`，因t1已有线程未处理，会导致`std::terminate()`。

**注意：** 赋值前必须确保原有线程已`join()`或`detach()`。

## 2. 线程所有权的函数传递与返回

### 2.1 线程所有权作为返回值

```cpp
#include <thread>

void some_function() {}
std::thread f() {
    return std::thread(some_function);
}

void some_other_function(int) {}
std::thread g() {
    std::thread t(some_other_function, 42);
    return t;
}
```

### 2.2 线程所有权作为参数传递

```cpp
#include <thread>

void f(std::thread t) {
    if (t.joinable()) t.join();
}
void g() {
    f(std::thread([]{ std::cout << "lambda thread\n"; }));
    std::thread t([]{ std::cout << "another thread\n"; });
    f(std::move(t));
}
```

## 3. 线程所有权的RAII管理：scoped_thread

通过RAII思想，`scoped_thread`类在析构时自动`join()`线程，防止资源泄漏。

```cpp
#include <thread>
#include <stdexcept>

class scoped_thread {
    std::thread t;
public:
    explicit scoped_thread(std::thread t_): t(std::move(t_)) {
        if (!t.joinable()) throw std::logic_error("No thread");
    }
    ~scoped_thread() { t.join(); }
    scoped_thread(scoped_thread const&) = delete;
    scoped_thread& operator=(scoped_thread const&) = delete;
};

struct func {
    void operator()(int& i) { ++i; }
};

void example() {
    int some_local_state = 0;
    scoped_thread t(std::thread(func(), std::ref(some_local_state)));
    // do_something_in_current_thread();
}
```

## 4. 线程容器与批量管理

将`std::thread`放入`std::vector`等容器，可批量管理线程。

```cpp
#include <vector>
#include <thread>
#include <algorithm>

void do_work(unsigned id) {
    std::cout << "Thread " << id << " working\n";
}

void batch_threads() {
    std::vector<std::thread> threads;
    for (unsigned i = 0; i < 20; ++i) {
        threads.push_back(std::thread(do_work, i));
    }
    std::for_each(threads.begin(), threads.end(),
                  std::mem_fn(&std::thread::join));
}
```

## 5. 运行时决定线程数量：并行accumulate

利用`std::thread::hardware_concurrency()`动态决定线程数，实现并行累加。

```cpp
#include <vector>
#include <thread>
#include <numeric>
#include <algorithm>
#include <functional>
#include <iostream>

// 块处理器
template<typename Iterator, typename T>
struct accumulate_block {
    void operator()(Iterator first, Iterator last, T& result) {
        result = std::accumulate(first, last, result);
    }
};

template<typename Iterator, typename T>
T parallel_accumulate(Iterator first, Iterator last, T init) {
    unsigned long const length = std::distance(first, last);
    if (!length) return init;
    unsigned long const min_per_thread = 25;
    unsigned long const max_threads = (length + min_per_thread - 1) / min_per_thread;
    unsigned long const hardware_threads = std::thread::hardware_concurrency();
    unsigned long const num_threads = std::min(hardware_threads != 0 ? hardware_threads : 2, max_threads);
    unsigned long const block_size = length / num_threads;
    std::vector<T> results(num_threads);
    std::vector<std::thread> threads(num_threads - 1);
    Iterator block_start = first;
    for (unsigned long i = 0; i < (num_threads - 1); ++i) {
        Iterator block_end = block_start;
        std::advance(block_end, block_size);
        threads[i] = std::thread(accumulate_block<Iterator, T>(), block_start, block_end, std::ref(results[i]));
        block_start = block_end;
    }
    accumulate_block<Iterator, T>()(block_start, last, results[num_threads - 1]);
    std::for_each(threads.begin(), threads.end(), std::mem_fn(&std::thread::join));
    return std::accumulate(results.begin(), results.end(), init);
}

void test_parallel_accumulate() {
    std::vector<int> v(1000, 1);
    int sum = parallel_accumulate(v.begin(), v.end(), 0);
    std::cout << "Sum: " << sum << std::endl;
}
```

## 6. 线程标识与线程ID

每个线程有唯一的`std::thread::id`，可用于识别和比较线程。

```cpp
#include <thread>
#include <iostream>

void print_thread_id() {
    std::cout << "Thread id: " << std::this_thread::get_id() << std::endl;
}

void thread_id_example() {
    std::thread t1(print_thread_id);
    std::thread t2(print_thread_id);
    t1.join();
    t2.join();
}
```

线程ID可用于容器键、比较、排序等。

---

本章详细介绍了C++11线程所有权的转移、RAII管理、批量线程管理、并行算法实现与线程ID的使用。掌握这些内容是高效安全并发编程的基础。
