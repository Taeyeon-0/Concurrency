# 1.线程管理基础

在 C++11 之前，编写跨平台的并发程序是一场噩梦（需要分别处理 `pthreads` 和 `Windows API`）。C++11 的出现是 C++ 历史上的一个里程碑，它不仅引入了现代化的语法，更重要的是引入了**标准化的内存模型**和**标准线程库**。

**第一个并发程序**

```cpp
#include <iostream>
#include <thread>

static void hello_concurrent() {
    std::cout << "Hello Concurrent" << std::endl;
}

int main() {
    std::thread t(hello_concurrent);
    t.join();
    
    return 0;
}
```

在 C++ 中，每个程序至少包含一个线程——即执行 `main()` 函数的主线程。当我们需要并行执行任务时，可以启动额外的线程，这些线程拥有独立的入口函数，并与主线程并发运行。

管理线程的生命周期是并发编程的第一课。无论是启动线程、等待它结束，还是将其置于后台运行，都需要严格遵循 C++ 标准库的规则。如果管理不当，轻则资源泄漏，重则导致程序崩溃（调用 `std::terminate()`）。

## 启动线程

在 C++ 中，启动一个线程的核心是构造一个 `std::thread` 对象。只要是“可调用（Callable）”的类型，都可以作为线程的入口。

### 启动方式

**普通函数：**

最简单的形式是传递一个无参数、无返回值的普通函数：

```cpp
void do_work();
std::thread t(do_work);
```

**函数对象：**

可以使用函数对象（重载了 `operator()` 的类）

```cpp
class Task {
public:
    void operator()() const {
        // 执行任务...
    }
};
std::thread t{ Task() }; 
```

**Lambda 表达式（推荐）：**

Lambda 表达式不仅简洁，还能通过捕获列表轻松处理上下文依赖：

```cpp
std::thread t([]{
    do_something();
});
```

**警惕：C++ "最令人头痛的语法解析"**

当尝试直接传递临时构造的函数对象时，C++ 编译器可能会将其误判为函数声明：

```cpp
// 错误：这被解析为声明了一个名为 t 的函数，
// 它接受一个返回 Task 的函数指针，并返回 std::thread
std::thread t(Task());
```

**解决方案：**

1.**多加一层括号：** 

```cpp
std::thread t((Task()));
```

2.**统一初始化语法（C++11）：**

```cpp
std::thread t{Task()};
```

3.**使用 Lambda：** 

```cpp
std::thread t([]{ Task()(); });
```

## 线程的生命周期

启动线程后，必须在 `std::thread` 对象销毁前明确决定它的命运：

- **Join：** 等待线程执行完毕。
- **Detach：** 让线程在后台自主运行，切断与主线程的联系。

**警告：** 如果在 `std::thread` 对象析构时（通常是离开作用域时）既没有 join 也没有 detach，程序将调用 `std::terminate()` 立即终止。

### 悬空引用

如果决定 detach 线程，或者在 join 之前线程依然在运行，必须确保**线程访问的数据在其运行期间始终有效**。

最常见的错误是：线程持有了宿主函数局部变量的指针或引用，而宿主函数已经结束，导致变量被销毁

```cpp
// 错误示范片段
struct Func {
    int& i;
    Func(int& i_) : i(i_) {}
    void operator()() {
        // 访问引用 i，可能导致未定义行为
        for(unsigned j=0; j<1000000; ++j) {
            do_something(i); 
        }
    }
};

void oops() {
    int local_state = 0;
    Func my_func(local_state);
    std::thread t(my_func);
    t.detach(); // oops函数结束，local_state销毁，但线程t可能还在运行并访问它
}
```

## 安全地等待线程：RAII 惯用法

虽然 `t.join()` 可以等待线程结束，但在异常环境下直接调用是不安全的。如果在启动线程后、调用 `join()` 前抛出了异常，`join()` 会被跳过，导致 `std::thread` 析构时触发程序终止。

### 传统的 try-catch

```cpp
std::thread t(func);
try {
    do_something_else();
} catch(...) {
    t.join(); // 发生异常时必须手动 join
    throw;
}
t.join();
```

这种写法啰嗦且容易遗漏。

### 使用 RAII（资源获取即初始化）

利用 C++ 的对象生命周期机制，编写一个 `thread_guard` 类，在析构函数中自动处理 join，是更优雅的解决方案。

```cpp
class thread_guard {
    std::thread& t;
public:
    explicit thread_guard(std::thread& t_) : t(t_) {}
    ~thread_guard() {
        if(t.joinable()) { // 必须检查是否可以 join
            t.join();
        }
    }
    // 禁止拷贝，防止多重 join
    thread_guard(const thread_guard&) = delete;
    thread_guard& operator=(const thread_guard&) = delete;
};
```

## 后台守护线程与参数传递

有时我们需要线程在后台长期运行（如监控文件系统、清理缓存），这种线程通常被称为**守护线程（Daemon Thread）**。使用 `detach()` 可以实现“发后即忘（Fire and Forget）”。

### 传递参数

`std::thread` 的构造函数是变参模板，可以直接传递参数。参数默认会被**拷贝**到线程的独立内存空间中，这使得多线程传参非常安全（除非传递的是指针）。

```cpp
void edit_document(std::string const& filename) { ... }
// 参数被拷贝，新线程拥有自己的 filename 副本
std::thread t(edit_document, "report.pdf");
t.detach();
```

### 场景模拟：多文档编辑

假设我们在开发一个文字处理软件，每次打开新文档都启动一个分离的线程，互不阻塞。

```cpp
#include <iostream>
#include <thread>
#include <string>
#include <chrono>
#include <vector>

void edit_document(std::string filename) {
    std::cout << "[Thread " << std::this_thread::get_id() 
              << "] Opening document: " << filename << std::endl;
    
    // 模拟文档编辑过程
    for (int i = 0; i < 3; ++i) {
        std::this_thread::sleep_for(std::chrono::milliseconds(500));
        std::cout << "[Thread " << std::this_thread::get_id() 
                  << "] Autosaving " << filename << "..." << std::endl;
    }
    
    std::cout << "[Thread " << std::this_thread::get_id() 
              << "] Finished editing " << filename << std::endl;
}

int main() {
    std::cout << "[Main] Application started.\n";

    // 模拟用户打开多个文档
    std::vector<std::string> docs = {"resume.doc", "budget.xls", "notes.txt"};

    for (const auto& doc : docs) {
        // 启动新线程处理文档，并传入文件名参数
        std::thread t(edit_document, doc);
        
        // 分离线程，让其在后台独立运行
        t.detach();
    }

    std::cout << "[Main] All documents opened. Main thread continues...\n";

    // 暂停主线程，防止主程序退出导致后台线程被强制关闭（仅为了演示效果）
    std::this_thread::sleep_for(std::chrono::seconds(3));
    
    std::cout << "[Main] Application exiting.\n";
    return 0;
}
```

# 2.向线程函数传递参数

在 C++ 中，启动线程时传递参数的语法看起来非常直观——直接在 `std::thread` 构造函数中追加参数即可。然而，由于线程拥有独立的栈空间和生命周期，参数传递的底层机制并不像普通函数调用那样简单。如果不了解 `std::thread` 的内部拷贝行为，很容易陷入“悬空指针”或“数据未更新”的陷阱。

## 基础传参：默认的拷贝行为

`std::thread` 的构造函数是一个变参模板，它会将传入的参数**拷贝**（或移动）到新线程的内部存储空间中。即使线程函数的参数签名是引用，`std::thread` 依然会先拷贝一份数据，然后再将这份拷贝的引用传递给线程函数。

```cpp
void f(int i, std::string const& s);

// "hello" 是 char const*，它会被拷贝到线程存储中，
// 然后在线程上下文中转换为 std::string
std::thread t(f, 3, "hello");
```

### 陷阱一：隐式转换与悬空指针

当我们将一个指向局部变量的指针传递给线程，并期望它在线程内部隐式转换为另一种类型（如 `std::string`）时，极易发生灾难。

**❌ 错误的做法**

```cpp
void f(int i, std::string const& s);

void oops(int some_param) {
    char buffer[1024];
    sprintf(buffer, "%i", some_param);
    
    // 危险！传递的是 char* 指针。
    // 线程启动可能是异步的，oops 函数可能在线程开始执行转换前就结束了。
    // 此时 buffer 已销毁，线程将访问悬空指针。
    std::thread t(f, 3, buffer); 
    t.detach();
}
```

**✅ 正确的做法**

解决方案是在传递给 `std::thread` 之前，显式创建一个临时对象。这样，拷贝到线程内部的就是这个临时的 `std::string` 对象，而非指针。

```cpp
// 安全：在主线程上下文中完成 string 的构造和拷贝
std::thread t(f, 3, std::string(buffer));
```

### 陷阱二：引用传递失效

既然 `std::thread` 默认拷贝参数，那么当我们想要线程修改主线程中的数据时，直接在函数签名中写引用是**无效**的。

**❌ 无效的引用传递**

```cpp
void update_data(int& data) { 
    data += 10; 
}

void f() {
    int local_data = 0;
    // 编译通过，但逻辑错误！
    // 线程内部持有的是 local_data 的拷贝。
    // update_data 修改的是拷贝，local_data 依然是 0。
    std::thread t(update_data, local_data); 
    t.join();
}
```

**✅ 使用 `std::ref`**

如果需要传递真正的引用，必须使用 `std::ref`（或者 `std::cref` 传递 const 引用）来包装参数。它会生成一个 `reference_wrapper`，告诉 `std::thread` 不要拷贝对象，而是拷贝引用。

```cpp
std::thread t(update_data, std::ref(local_data));
```

## 传递类成员函数

`std::thread` 可以很方便地配合面向对象编程。如果想在一个对象上运行线程，需要传递两个关键信息：**函数指针**和**对象指针**。

```cpp
class Worker {
public:
    void do_work(int count);
};

Worker w;
// 语法：&类名::函数名, 对象指针, 参数...
std::thread t(&Worker::do_work, &w, 42);
```

这里的 `&w` 是作为成员函数的隐含参数 `this` 指针传递的。

## 移动语义：传递独占资源

有些对象是不可拷贝的（Non-copyable），例如 `std::unique_ptr`、`std::fstream` 等。如果我们想把这些对象的所有权移交给线程，必须使用 `std::move`。

这在构建“生产者-消费者”模型时非常有用，比如主线程创建了一个大对象，然后将其所有权“移交”给后台线程处理，主线程不再持有。

```cpp
void process_ptr(std::unique_ptr<BigObject> p);

std::unique_ptr<BigObject> p(new BigObject);
// p 的所有权转移到了线程内部，主线程中的 p 变为空
std::thread t(process_ptr, std::move(p));
```